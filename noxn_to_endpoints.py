"""Convert nitrate concentrations to health and economic endpoints."""
import os

from osgeo import gdal
import numpy
import pandas

import pygeoprocessing

# predicted nitrate concentrations in surface and groundwater, for a series of
# scenarios
_NOXN_PATH_DICT = {
    'baseline': "",
}

# base data dictionary
_BASE_DATA_PATH_DICT = {
    'water_source_table': "F:/NCI_NDR/Data endpoints/water_source_by_country_id.csv",
    'cancer_rate_table': "F:/NCI_NDR/Data endpoints/cancer_rate_by_country_id.csv",
    'countries_raster': "F:/NCI_NDR/Data%20national_boundaries/countries_iso3.tif",
    'population_raster': TODO,
}

# directory to hold temporary outputs
_PROCESSING_DIR = "F:/NCI_NDR/rf_processing"

# nodata value for output rasters
_TARGET_NODATA = -1.0


def calc_drinking_water_source_raster(save_as):
    """Generate a raster giving percent of drinking water from surface.

    This raster is generated by assigning country-level values in
    _BASE_DATA_PATH_DICT['water_source_table'] to countries identified in
    _BASE_DATA_PATH_DICT['countries_raster'].

    Parameters:
        save_as (string): location to save raster where country id values have
            been reclassified to proportion of drinking water supplied by
            surface water

    Side effects:
        creates or modifies a global raster at the location `save_as`

    Returns:
        None

    """
    drinking_df = pandas.read_csv(_BASE_DATA_PATH_DICT['water_source_table'])
    countryid_to_drinking = pandas.Series(
        drinking_df.perc_surface.values, index=drinking_df.id).to_dict()
    pygeoprocessing.reclassify_raster(
        (_BASE_DATA_PATH_DICT['countries_raster'], 1), countryid_to_drinking,
        save_as, gdal.GDT_Float32, _TARGET_NODATA)


def calc_background_cancer_rate_raster(save_as):
    """Generate a raster giving background cancer rate.

    This raster is generated by assigning country-level values in
    _BASE_DATA_PATH_DICT['cancer_rate_table'] to countries identified in
    _BASE_DATA_PATH_DICT['countries_raster'].

    Parameters:
        save_as (string): location to save raster where country id values have
            been reclassified to background cancer rate

    Side effects:
        creates or modifies a global raster at the location `save_as`

    Returns:
        None

    """
    rate_df = pandas.read_csv(_BASE_DATA_PATH_DICT['cancer_rate_table'])
    countryid_to_rate = pandas.Series(
        rate_df['Rate.per.person'].values, index=rate_df.id).to_dict()
    pygeoprocessing.reclassify_raster(
        (_BASE_DATA_PATH_DICT['countries_raster'], 1), countryid_to_rate,
        save_as, gdal.GDT_Float32, _TARGET_NODATA)


def calc_cancer_cases(noxn_in_drinking_water, population, background_rate):
    """Calculate noxn-attributable colorectal cancer cases per year.

    Convert nitrogen concentrations in drinking water into nitrate-
    attributable colorectal cancer cases per year, using a cancer slope factor
    of 0.04 cases per year per unit noxn from Temkin et al. (2019).

    Parameters:
        noxn_in_drinking_water (numpy.ndarray): estimated nitrate concentration
            in drinking water, in mg/L
        population (numpy.ndarray): inhabitants per grid cell
        background_rate (numpy.ndarray): country-specific background rate of
            colorectal cancer, in new cases per person per year

    Returns:
        cancer_cases, a numpy array of estimated nitrate-attributable cancer
            cases per year

    """
    cancer_cases = numpy.empty(population.shape, dtype=numpy.float32)
    cancer_cases[:] = _TARGET_NODATA
    valid_mask = []  # TODO
    cancer_cases[valid_mask] = (
        noxn_in_drinking_water[valid_mask] * population[valid_mask] *
        background_rate[valid_mask] * 0.04)
    return cancer_cases


def calc_treatment_costs(noxn_in_drinking_water, population):
    """Calculate nitrate abatement costs in USD per year.

    Convert nitrogen concentration in drinking water into nitrogen abatement
    costs. Where noxn is below the WHO drinking water limits for nitrates
    (11.3 mg/L noxn), it's assumed that no treatment is used and therefore the
    cost is zero. For areas exceeding exceeding the limits, the abatement cost
    is estimated by multiplying a constant abatement cost of 200 USD per person
    per year by the population.

    Parameters:
        noxn_in_drinking_water (numpy.ndarray): estimated nitrate concentration
            in drinking water, in mg/L
        population (numpy.ndarray): inhabitants per grid cell

    Returns:
        abatement_costs, a numpy array of estimated abatement costs for nitrate
            in drinking water in USD per year

    """
    abatement_costs = numpy.empty(population.shape, dtype=numpy.float32)
    abatement_costs[:] = _TARGET_NODATA
    valid_mask = []  # TODO
    threshold_conc = 11.3
    cost_per_person = 200
    abatement_costs = numpy.zeros(noxn_in_drinking_water.shape)
    exceeded_mask = (valid_mask & (noxn_in_drinking_water > threshold_conc))
    abatement_costs[exceeded_mask] = (
        population[exceeded_mask] * cost_per_person)
    return abatement_costs

def calc_endpoints():
    """Calculate health and economic endpoints from nitrate concentrations."""
    drinking_water_source_path = os.path.join(
        _PROCESSING_DIR, 'frac_surface.tif')
    if not os.path.isfile(drinking_water_source_path):
        calc_drinking_water_source_raster(drinking_water_source_path)

    background_cancer_rate_path = os.path.join(
        _PROCESSING_DIR, 'bg_cancer-rate.tif')
    if not os.path.isfile(background_cancer_rate_path):
        calc_background_cancer_rate_raster(background_cancer_rate_path)


def main():
    """Program entry point."""
    workflow()


if __name__ == '__main__':
    main()
